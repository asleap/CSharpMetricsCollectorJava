options {
  LOOKAHEAD = 5;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = true;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;

  MULTI = true;
  VISITOR = true;
}

PARSER_BEGIN(CSharpParser)

package csmc.javacc.generated;

import java.util.ArrayList;
import java.util.Collections;
import csmc.javacc.util.Tuple2;

/** Simple brace matcher. */
public class CSharpParser {

}

PARSER_END(CSharpParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN : // Tokens which should be created but should not be passed to the parser
{
  < SINGLE_LINE_COMMENT: ( "//" ) (~["\r","\n","\0","\u2028","\u2029"])* >
  | < MULTI_LINE_COMMENT: ( "/*" ) ("/"|((<ASTERISK>)* (~["/","*"])))* (<ASTERISK>)* ("/") >
}

TOKEN :
{
  // < NEW_LINE: ["\n"] | ("\r\n") >

  // Pre-processor
  < HASH: "#" >
  | < DEFINE: "define" >
  | < UNDEF: "undef" >

  // Keywords
  | < ABSTRACT: "abstract" >
  | < ADD: "add" >
  | < ALIAS: "alias" >
  | < AS: "as" >
  | < ASCENDING: "ascending" >
  | < ASSEMBLY: "assebmly" >
  | < AWAIT: "await" >
  | < BASE: "base" >
  | < BOOL: "bool" >
  | < BREAK : "break" >
  | < BY: "by" >
  | < BYTE: "byte" >
  | < CASE: "case" >
  | < CATCH: "catch" >
  | < CHAR: "char" >
  | < CHECKED: "checked" >
  | < CLASS: "class" >
  | < CONST: "const" >
  | < CONTINUE: "continue" >
  | < DECIMAL: "decimal" >
  | < _DEFAULT: "default" >
  | < DELEGATE: "delegate" >
  | < DESCENDING: "descending" >
  | < DO: "do" >
  | < DOUBLE: "double" >
  | < DYNAMIC: "dynamic" >
  | < ELSE: "else" >
  | < ENUM: "enum" >
  | < EQUALS: "equals" >
  | < EVENT: "event" >
  | < EXPLICIT: "explicit" >
  | < EXTERN: "extern" >
  | < FALSE: "false" >
  | < FIELD: "field" >
  | < FINALLY: "finally" >
  | < FIXED: "fixed" >
  | < FLOAT: "float" >
  | < FOR: "for" >
  | < FOREACH: "foreach" >
  | < FROM: "from" >
  | < GET: "get" >
  | < GOTO: "goto" >
  | < GROUP: "group" >
  | < IF: "if" >
  | < IMPLICIT: "implicit" >
  | < IN: "in" >
  | < INT: "int" >
  | < INTO: "into" >
  | < INTERFACE: "interface" >
  | < INTERNAL: "internal" >
  | < IS: "is" >
  | < JOIN: "join" >
  | < LET: "let" >
  | < LOCK: "lock" >
  | < LONG: "long" >
  | < METHOD: "method" >
  | < MODULE: "module" >
  | < NAMEOF: "nameof" >
  | < NAMESPACE: "namespace" >
  | < NEW: "new" >
  | < NULL: "null" >
  | < OBJECT: "object" >
  | < ON: "on" >
  | < OPERATOR: "operator" >
  | < ORDERBY: "orderby" >
  | < OUT: "out" >
  | < OVERRIDE: "override" >
  | < PARAM: "param" >
  | < PARAMS: "params" >
  | < PARTIAL: "partial" >
  | < PRIVATE: "private" >
  | < PROPERTY: "property" >
  | < PROTECTED: "protected" >
  | < PUBLIC: "public" >
  | < READONLY: "readonly" >
  | < REF: "ref" >
  | < REMOVE: "remove" >
  | < RETURN: "return" >
  | < SBYTE: "sbyte" >
  | < SEALED: "sealed" >
  | < SELECT: "select" >
  | < SET: "set" >
  | < SHORT: "short" >
  | < SIZEOF: "sizeof" >
  | < STACKALLOC: "stackalloc" >
  | < STATIC: "static" >
  | < STRING: "string" >
  | < STRUCT: "struct" >
  | < SWITCH: "switch" >
  | < THIS: "this" >
  | < THROW: "throw" >
  | < TRUE: "true" >
  | < TRY: "try" >
  | < TYPE: "type" >
  | < TYPEOF: "typeof" >
  | < UINT: "uint" >
  | < ULONG: "ulong" >
  | < UNCHECKED: "unchecked" >
  | < UNSAFE: "unsafe" >
  | < USHORT: "ushort" >
  | < USING: "using" >
  | < VAR: "var" >
  | < VIRTUAL: "virtual" >
  | < VOID: "void" >
  | < VOLATILE: "volatile" >
  | < WHEN: "when" >
  | < WHERE: "where" >
  | < WHILE: "while" >
  | < YIELD: "yield" >

  // Operatorss and punctuators
  | < AT: "@" >
  | < UNDERSCORE: "_" >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < LBRACKET: "[" >
  | < RBRACKET: "]" >
  | < LPAREN: "(" >
  | < RPAREN: ")" >
  | < DOT: "." >
  | < COMMA: "," >
  | < COLON: ":" >
  | < SEMICOLON: ";" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < ASTERISK: "*" >
  | < SLASH: "/" >
  | < PERCENT: "%" >
  | < AMPERSAND: "&" >
  | < VERTICAL: "|" >
  | < CARET: "^" >
  | < EXCLAMATION: "!" >
  | < TILDE: "~" >
  | < EQUAL: "=" >
  | < LESS: "<" >
  | < GREATER: ">" >
  | < QUESTION: "?" >
  | < DBL_QUESTION: "??" >
  | < DBL_COLON: "::" >
  | < DBL_PLUS: "++" >
  | < DBL_MINUS: "--" >
  | < DBL_AMPERSAND: "&&" >
  | < DBL_VERTICAL: "||" >
  | < DBL_EQUAL: "==" >
  | < EXCL_EQUAL: "!=" >
  | < LESS_EQUAL: "<=" >
  | < GREATER_EQUAL: ">=" >
  | < PLUS_EQUAL: "+=" >
  | < MINUS_EQUAL: "-=" >
  | < ASTERISK_EQUAL: "*=" >
  | < SLASH_EQUAL: "/=" >
  | < PERCENT_EQUAL: "%=" >
  | < AMPERSAND_EQUAL: "&=" >
  | < VERTICAL_EQUAL: "|=" >
  | < CARET_EQUAL: "^=" >
  | < DBL_LESS: "<<" >
  | < DBL_LESS_EQUAL: "<<=" >
  | < DBL_GREATER: ">>" >
  | < DBL_GREATER_EQUAL: ">>=" >
  | < EQUAL_GREATER: "=>" >
  | < MINUS_GREATER: "->" >

  // Literals
  | < IDENTIFIER: ("@")? ["_","a"-"z","A"-"Z"] (["_","a"-"z","A"-"Z","0"-"9"])* >
  | < INTEGER_LITERAL: ((("0x" | "0X")(["0"-"9", "a"-"f", "A"-"F"])+) | ((["0"-"9"])+)) ("UL"|"Ul"|"uL"|"ul"|"LU"|"Lu"|"lU"|"lu"|"U"|"u"|"L"|"l")? >
  | < REAL_LITERAL: ((["0"-"9"])+"."(["0"-"9"])+(["E","e"](["+","-"])?(["0"-"9"])+)?(["F","f","D","d","M","m"])?)
                    |("."(["0"-"9"])+(["E","e"](["+","-"])?(["0"-"9"])+)?(["F","f","D","d","M","m"])?)
                    |((["0"-"9"])+["E","e"](["+","-"])?(["0"-"9"])+(["F","f","D","d","M","m"])?)
                    |((["0"-"9"])+(["F","f","D","d","M","m"])) >
  | < CHARACTER_LITERAL: "'" ((~["'","\\","\r","\n","\0","\u2028","\u2029"])
                         |("\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v")
                         |("\\x"(["0"-"9","a"-"f","A"-"F"]){1,4})
                         |("\\u"(["0"-"9","a"-"f","A"-"F"]){4})
                         |("\\U"(["0"-"9","a"-"f","A"-"F"]){8})
                         ) "'" >
  | < STRING_LITERAL: ( "\"" ((~["'","\\","\r","\n","\0","\u2028","\u2029"])
                              |("\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v")
                              |("\\x"(["0"-"9","a"-"f","A"-"F"]){1,4})
                              |("\\u"(["0"-"9","a"-"f","A"-"F"]){4}) | ("\\U"(["0"-"9","a"-"f","A"-"F"]){8}))*
                        "\"")
                      | ( "@\"" (( ~["\""] )
                                 |( "\"\"" ))*
                          "\"") >
}

/** Root production. */
ASTInput Input() :
{}
{
  Start() <EOF>
  { return jjtThis; }
}

/** Brace matching production. */
void Start() :
{}
{
  CompilationUnit()
}

void CompilationUnit() :
{}
{
  ExternAliasDirectiveList() UsingDirectiveList() GlobalAttributesOpt() NamespaceMemberDeclarationList()
}

void ExternAliasDirectiveList() :
{}
{
  [ ExternAliasDirective() ExternAliasDirectiveList() ]
}

void UsingDirectiveList() :
{}
{
  [ UsingDirective() UsingDirectiveList() ]
}

void GlobalAttributesOpt() :
{}
{
 GlobalAttributes()
 | {}
}

void NamespaceMemberDeclarationList() :
{}
{
  [ NamespaceMemberDeclaration() NamespaceMemberDeclarationList() ]
}

void ExternAliasDirective() :
{}
{
  <EXTERN> <ALIAS> Identifier() <SEMICOLON>
}

void UsingDirective() :
{}
{
  UsingAliasDirective()
  | UsingNamespaceDirective()
  | UsingStaticDirective()
}

void UsingAliasDirective() :
{}
{
  <USING> Identifier() <EQUAL> NamespaceOrTypeName() <SEMICOLON>
}

ASTNamespaceOrTypeName NamespaceOrTypeName() :
{ ArrayList<String> ns = new ArrayList<String>(); SimpleNode sn1, sn2; }
{
  sn1 = Identifier() sn2 = TypeArgumentListOpt() NamespaceOrTypeNamePrime(ns) {
    ns.add((String) sn1.jjtGetValue() + (String) sn2.jjtGetValue());
    Collections.reverse(ns);
    String[] nsArray = new String[ns.size()];
    ns.toArray(nsArray);
    jjtThis.value = nsArray;
    return jjtThis;
  }

  | sn1 = QualifiedAliasMember() NamespaceOrTypeNamePrime(ns) {
    ns.add((String) sn1.jjtGetValue());
    Collections.reverse(ns);
    String[] nsArray = new String[ns.size()];
    ns.toArray(nsArray);
    jjtThis.value = nsArray;
    return jjtThis;
  }
}

ASTNamespaceOrTypeNamePrime NamespaceOrTypeNamePrime(ArrayList<String> ns) :
{ SimpleNode sn1, sn2; }
{
  <DOT> sn1 = Identifier() sn2 = TypeArgumentListOpt() NamespaceOrTypeNamePrime(ns) {
    ns.add((String) sn1.jjtGetValue() + (String) sn2.jjtGetValue());
    return jjtThis;
  }

| {}    { return jjtThis; }
}

ASTTypeArgumentListOpt TypeArgumentListOpt() :
{ SimpleNode sn; }
{
  sn = TypeArgumentList()                           { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | {}                                              { jjtThis.value = ""; return jjtThis; }
}

ASTTypeArgumentList TypeArgumentList() :
{ Token t1, t2; SimpleNode sn; }
{
  t1 = <LESS> sn = TypeArguments() t2 = <GREATER>   { jjtThis.value = t1.image + (String) sn.jjtGetValue() + t2.image; return jjtThis; }
}

ASTTypeArguments TypeArguments() :
{ SimpleNode sn1, sn2; }
{
  sn1 = TypeArgument() sn2 = MoreTypeArguments()    { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
}

ASTMoreTypeArguments MoreTypeArguments() :
{ Token t; SimpleNode sn1, sn2; }
{
  t = <COMMA> sn1 = TypeArgument() sn2 = MoreTypeArguments() {
    jjtThis.value = t.image + " " + (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue();
    return jjtThis;
  }

  | {}                                              { jjtThis.value = ""; return jjtThis; }
}

ASTTypeArgument TypeArgument() :
{ SimpleNode sn; }
{
  sn = Type()                                       { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTType Type() :
{ Token t1, t2; SimpleNode sn1, sn2; }
{
  // ValueType()
  sn1 = TypeName() sn2 = TypePrime()                { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
  | sn1 = SimpleType() sn2 = TypePrime()            { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
  | sn1 = ClassType() sn2 = TypePrime()             { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
  | sn1 = InterfaceType() sn2 = TypePrime()         { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
  | sn1 = DelegateType() sn2 = TypePrime()          { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
  | sn1 = TypeParameter() sn2 = TypePrime()         { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
  | t1 = <VOID> t2 = <ASTERISK> sn2 = TypePrime()   { jjtThis.value = t1.image + t2.image + (String) sn2.jjtGetValue(); return jjtThis; }
}

ASTTypePrime TypePrime() :
{ Token t; SimpleNode sn1, sn2; }
{
  t = <QUESTION> sn2 = TypePrime()                  { jjtThis.value = t.image + (String) sn2.jjtGetValue(); return jjtThis; }
  | sn1 = RankSpecifierList() sn2 = TypePrime()     { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
  | t = <ASTERISK> sn2 = TypePrime()                { jjtThis.value = t.image + (String) sn2.jjtGetValue(); return jjtThis; }
  | {}                                              { jjtThis.value = ""; return jjtThis; }
}

ASTValueType ValueType() :
{ SimpleNode sn; }
{
  sn = StructType()                                 { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | sn = EnumType()                                 { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTStructType StructType() :
{ SimpleNode sn; }
{
  sn = NullableType()                               { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | sn = TypeName()                                 { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | sn = SimpleType()                               { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTTypeName TypeName() :
{ SimpleNode sn; }
{
  sn = NamespaceOrTypeName()                        { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTSimpleType SimpleType() :
{ Token t; SimpleNode sn; }
{
  sn = NumericType()                                { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | t = <BOOL>                                      { jjtThis.value = t.image; return jjtThis; }
}

ASTNumericType NumericType() :
{ Token t; SimpleNode sn; }
{
  sn = IntegralType()                               { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | sn = FloatingPointType()                        { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | t = <DECIMAL>                                   { jjtThis.value = t.image; return jjtThis; }
}

ASTIntegralType IntegralType() :
{ Token t; }
{
  t = <SBYTE>                                           { jjtThis.value = t.image; return jjtThis; }
  | t = <BYTE>                                          { jjtThis.value = t.image; return jjtThis; }
  | t = <SHORT>                                         { jjtThis.value = t.image; return jjtThis; }
  | t = <USHORT>                                        { jjtThis.value = t.image; return jjtThis; }
  | t = <INT>                                           { jjtThis.value = t.image; return jjtThis; }
  | t = <UINT>                                          { jjtThis.value = t.image; return jjtThis; }
  | t = <LONG>                                          { jjtThis.value = t.image; return jjtThis; }
  | t = <ULONG>                                         { jjtThis.value = t.image; return jjtThis; }
  | t = <CHAR>                                          { jjtThis.value = t.image; return jjtThis; }
}

ASTFloatingPointType FloatingPointType() :
{ Token t; }
{
  t = <FLOAT>                                       { jjtThis.value = t.image; return jjtThis; }
  | t = <DOUBLE>                                    { jjtThis.value = t.image; return jjtThis; }
}

ASTNullableType NullableType() :
{ Token t; SimpleNode sn; }
{
  sn = NonNullableValueType() t = <QUESTION>        { jjtThis.value = (String) sn.jjtGetValue() + t.image; return jjtThis; }
}

ASTNonNullableValueType NonNullableValueType() :
{ SimpleNode sn; }
{
  sn = Type()                                       { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTEnumType EnumType() :
{ SimpleNode sn; }
{
  sn = TypeName()                                   { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTReferenceType ReferenceType() :
{ SimpleNode sn; }
{
  sn = ClassType()                                  { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | sn = InterfaceType()                            { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | sn = ArrayType()                                { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | sn = DelegateType()                             { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTClassType ClassType() :
{ Token t; SimpleNode sn; }
{
  sn = TypeName()                                   { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | t = <OBJECT>                                    { jjtThis.value = t.image; return jjtThis; }
  | t = <DYNAMIC>                                   { jjtThis.value = t.image; return jjtThis; }
  | t = <STRING>                                    { jjtThis.value = t.image; return jjtThis; }
}

ASTInterfaceType InterfaceType() :
{ SimpleNode sn; }
{
  sn = TypeName()                                        { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTArrayType ArrayType() :
{ SimpleNode sn1, sn2; }
{
  sn1 = NonArrayType() sn2 = RankSpecifierList()    { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
}

ASTNonArrayType NonArrayType() :
{ SimpleNode sn; }
{
  sn = Type()                                       { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTRankSpecifierList RankSpecifierList() :
{ SimpleNode sn1, sn2; }
{
  sn1 = RankSpecifier()                             { jjtThis.value = sn1.jjtGetValue(); return jjtThis; }
  | sn1 = RankSpecifier() sn2 = RankSpecifierList() { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
}

ASTRankSpecifier RankSpecifier() :
{ Token t1, t2; SimpleNode sn; }
{
  t1 = <LBRACKET> sn = DimSeparatorList() t2 = <RBRACKET> {
    jjtThis.value = t1.image + (String) sn.jjtGetValue() + t2.image; return jjtThis;
  }
}

ASTDimSeparatorList DimSeparatorList() :
{ SimpleNode sn1, sn2; }
{
  sn1 = DimSeparator() sn2 = DimSeparatorList()     { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
  | {}                                              { jjtThis.value = ""; return jjtThis; }
}

ASTDimSeparator DimSeparator() :
{ Token t; }
{
  t = <COMMA>                                           { jjtThis.value = t.image; return jjtThis; }
}

ASTDelegateType DelegateType() :
{ SimpleNode sn; }
{
  sn = TypeName()                                       { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTTypeParameter TypeParameter() :
{ SimpleNode sn; }
{
  sn = Identifier()                                     { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTTypeUnsafe TypeUnsafe() :
{ SimpleNode sn; }
{
  sn = PointerType()                                    { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTPointerType PointerType() :
{ Token t1, t2; SimpleNode sn; }
{
  sn = UnmanagedType() t2 = <ASTERISK>                  { jjtThis.value = (String) sn.jjtGetValue() + t2.image; return jjtThis; }
  | t1 = <VOID> t2 = <ASTERISK>                         { jjtThis.value = t1.image + t2.image; return jjtThis; }
}

ASTUnmanagedType UnmanagedType() :
{ SimpleNode sn; }
{
  sn = Type()                                           { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
}

ASTQualifiedAliasMember QualifiedAliasMember() :
{ Token t; SimpleNode sn1, sn2, sn3;}
{
  sn1 = Identifier() t = <DBL_COLON> sn2 = Identifier() sn3 = TypeArgumentListOpt() {
    jjtThis.value = (String) sn1.jjtGetValue() + t.image + (String) sn2.jjtGetValue() + (String) sn3.jjtGetValue();
    return jjtThis;
  }
}

void UsingNamespaceDirective() :
{}
{
  <USING> NamespaceName() <SEMICOLON>
}

void NamespaceName() :
{}
{
  NamespaceOrTypeName()
}

void UsingStaticDirective() :
{}
{
  <USING> <STATIC> TypeName() <SEMICOLON>
}

void GlobalAttributes() :
{}
{
  GlobalAttributesSectionList()
}

void GlobalAttributesSectionList() :
{}
{
  GlobalAttributesSection() GlobalAttributesSectionList()
  | GlobalAttributesSection()
}

void GlobalAttributesSection() :
{}
{
  <LBRACKET> GlobalAttributeTargetSpecifier() AttributeList() <COMMA> <RBRACKET>
  | <LBRACKET> GlobalAttributeTargetSpecifier() AttributeList() <RBRACKET>
}

void GlobalAttributeTargetSpecifier() :
{}
{
  GlobalAttributeSpecifier() <COLON>
}

void GlobalAttributeSpecifier() :
{}
{
  <ASSEMBLY>
  | <MODULE>
}

void AttributeList() :
{}
{
  Attribute() MoreAttributes()
}

void Attribute() :
{}
{
  AttributeName() AttributeArgumentsOpt()
}

void MoreAttributes() :
{}
{
  [ <COMMA> Attribute() MoreAttributes() ]
}

void AttributeName() :
{}
{
  TypeName()
}

void AttributeArgumentsOpt() :
{}
{
  [ AttributeArguments() ]
}

void AttributeArguments() :
{}
{
  <LPAREN> PositionalArgumentListOpt() <COMMA> NamedArgumentList() <RPAREN>
  | <LPAREN> PositionalArgumentListOpt() <RPAREN>
  | <LPAREN> NamedArgumentList() <RPAREN>
}

void PositionalArgumentListOpt() :
{}
{
  [ PositionalArgumentList() ]
}

void PositionalArgumentList() :
{}
{
  PositionalArgument() MorePositionalArguments()
}

void PositionalArgument() :
{}
{
  AttributeArgumentExpression()
}

void AttributeArgumentExpression() :
{}
{
  Expression()
}

void MorePositionalArguments() :
{}
{
  [ <COMMA> PositionalArgument() MorePositionalArguments() ]
}

void NamedArgumentList() :
{}
{
  NamedArgument() MoreNamedArguments()
}

void NamedArgument() :
{}
{
  Identifier() <EQUAL> AttributeArgumentExpression()
}

void MoreNamedArguments() :
{}
{
  [ <COMMA> NamedArgument() MoreNamedArguments() ]
}

void NamespaceMemberDeclaration() :
{}
{
  NamespaceDeclaration()
  | TypeDeclaration()
}

ASTNamespaceDeclaration NamespaceDeclaration() :
{ SimpleNode namespaceName; }
{
  <NAMESPACE> namespaceName = QualifiedIdentifier() NamespaceBody() SemicolonOpt() {
    jjtThis.value = namespaceName.jjtGetValue();
    return jjtThis;
  }
}

void SemicolonOpt() :
{}
{
  [ <SEMICOLON> ]
}

ASTQualifiedIdentifier QualifiedIdentifier() :
{ SimpleNode sn1, sn2; }
{
  sn1 = Identifier() sn2 = MoreIdentifiers()    { jjtThis.value = (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue(); return jjtThis; }
}

ASTMoreIdentifiers MoreIdentifiers() :
{ Token t; SimpleNode sn1, sn2; }
{
  t = <DOT> sn1 = Identifier() sn2 = MoreIdentifiers() {
    jjtThis.value = t.image + (String) sn1.jjtGetValue() + (String) sn2.jjtGetValue();
    return jjtThis;
  }

  | {}  { jjtThis.value = ""; return jjtThis; }
}

void NamespaceBody() :
{}
{
  <LBRACE> ExternAliasDirectiveList() UsingDirectiveList() NamespaceMemberDeclarationList() <RBRACE>
}

void TypeDeclaration() :
{}
{
  ClassDeclaration()
  | StructDeclaration()
  | InterfaceDeclaration()
  | EnumDeclaration()
  | DelegateDeclaration()
}

ASTClassDeclaration ClassDeclaration() :
{ SimpleNode className, classBase; }
{
  AttributesOpt() ClassModifierList() PartialOpt() <CLASS> className = Identifier() TypeParameterListOpt() classBase = ClassBaseOpt() TypeParameterConstraintsClauseList() ClassBody() SemicolonOpt() {
    jjtThis.value = new Tuple2(className.jjtGetValue(), classBase.jjtGetValue());
    return jjtThis;
  }
}

void AttributesOpt() :
{}
{
  [ Attributes() ]
}

void ClassModifierList() :
{}
{
  [ ClassModifier() ClassModifierList() ]
}

void PartialOpt() :
{}
{
  [ <PARTIAL> ]
}

void TypeParameterListOpt() :
{}
{
  [ TypeParameterList() ]
}

ASTClassBaseOpt ClassBaseOpt() :
{ SimpleNode sn; }
{
  sn = ClassBase()  { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | {}  { return jjtThis; }
}

void TypeParameterConstraintsClauseList() :
{}
{
  [ TypeParameterConstraintsClause() TypeParameterConstraintsClauseList() ]
}

void Attributes() :
{}
{
  AttributeSectionList()
}

void AttributeSectionList() :
{}
{
  AttributeSection() AttributeSectionList()
  | AttributeSection()
}

void AttributeSection() :
{}
{
  <LBRACKET> AttributeTargetSpecifierOpt() AttributeList() <COMMA> <RBRACKET>
  | <LBRACKET> AttributeTargetSpecifierOpt() AttributeList() <RBRACKET>
}

void AttributeTargetSpecifierOpt() :
{}
{
  [ AttributeTargetSpecifier() ]
}

void AttributeTargetSpecifier() :
{}
{
  AttributeTarget() <COLON>
}

void AttributeTarget() :
{}
{
  <FIELD>
  | <EVENT>
  | <METHOD>
  | <PARAM>
  | <PROPERTY>
  | <RETURN>
  | <TYPE>
}

void ClassModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
  | <ABSTRACT>
  | <SEALED>
  | <STATIC>
  | ClassModifierUnsafe()
}

void ClassModifierUnsafe() :
{}
{
  <UNSAFE>
}

void TypeParameterList() :
{}
{
  <LESS> TypeParameters() <GREATER>
}

void TypeParameters() :
{}
{
  AttributesOpt() TypeParameter() TypeParametersPrime()
}

void TypeParametersPrime() :
{}
{
  [ <COMMA> AttributesOpt() TypeParameter() TypeParametersPrime() ]
}

ASTClassBase ClassBase() :
{ SimpleNode sn; }
{
  <COLON> sn = ClassType() <COMMA> InterfaceTypeList()  { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | <COLON> sn = ClassType()    { jjtThis.value = sn.jjtGetValue(); return jjtThis; }
  | <COLON> InterfaceTypeList() { return jjtThis; }
}

void InterfaceTypeList() :
{}
{
  InterfaceType() MoreInterfaceTypes()
}

void MoreInterfaceTypes() :
{}
{
  [ <COMMA> InterfaceType() MoreInterfaceTypes() ]
}

void TypeParameterConstraintsClause() :
{}
{
  <WHERE> TypeParameter() <COLON> TypeParameterConstraints()
}

void TypeParameterConstraints() :
{}
{
  PrimaryConstraint() <COMMA> SecondaryConstraints() <COMMA> ConstructorConstraint()
  | PrimaryConstraint() <COMMA> SecondaryConstraints()
  | PrimaryConstraint() <COMMA> ConstructorConstraint()
  | PrimaryConstraint()
  | SecondaryConstraints() <COMMA> ConstructorConstraint()
  | SecondaryConstraints()
  | ConstructorConstraint()
}

void PrimaryConstraint() :
{}
{
  ClassType()
  | <CLASS>
  | <STRUCT>
}

void SecondaryConstraints() :
{}
{
  InterfaceType() SecondaryConstraintsPrime()
  | TypeParameter() SecondaryConstraintsPrime()
}

void SecondaryConstraintsPrime() :
{}
{
  <COMMA> InterfaceType() SecondaryConstraintsPrime()
  | <COMMA> TypeParameter() SecondaryConstraintsPrime()
  | {}
}

void ConstructorConstraint() :
{}
{
  <NEW> <LPAREN> <RPAREN>
}

void ClassBody() :
{}
{
  <LBRACE> ClassMemberDeclarationList() <RBRACE>
}

void ClassMemberDeclarationList() :
{}
{
  [ ClassMemberDeclaration() ClassMemberDeclarationList() ]
}

void ClassMemberDeclaration() :
{}
{
  ConstantDeclaration()
  | FieldDeclaration()
  | MethodDeclaration()
  | PropertyDeclaration()
  | EventDeclaration()
  | IndexerDeclaration()
  | OperatorDeclaration()
  | ConstructorDeclaration()
  | DestructorDeclaration()
  | StaticConstructorDeclaration()
  | TypeDeclaration()
}

void ConstantDeclaration() :
{}
{
  AttributesOpt() ConstantModifierList() <CONST> Type() ConstantDeclarators() <SEMICOLON>
}

void ConstantModifierList() :
{}
{
  [ ConstantModifier() ConstantModifierList() ]
}

void ConstantModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
}

void ConstantDeclarators() :
{}
{
  ConstantDeclarator() MoreConstantDeclarators()
}

void ConstantDeclarator() :
{}
{
  Identifier() <EQUAL> ConstantExpression()
}

void ConstantExpression() :
{}
{
  Expression()
}

void MoreConstantDeclarators() :
{}
{
  [ <COMMA> ConstantDeclarator() MoreConstantDeclarators() ]
}

void FieldDeclaration() :
{}
{
  AttributesOpt() FieldModifierList() Type() VariableDeclarators() <SEMICOLON>
}

void FieldModifierList() :
{}
{
  [ FieldModifier() FieldModifierList() ]
}

void FieldModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
  | <STATIC>
  | <READONLY>
  | <VOLATILE>
  | FieldModifierUnsafe()
}

void FieldModifierUnsafe() :
{}
{
  <UNSAFE>
}

void VariableDeclarators() :
{}
{
  VariableDeclarator() MoreVariableDeclarators()
}

void VariableDeclarator() :
{}
{
  Identifier() <EQUAL> VariableInitializer()
  | Identifier()
}

void VariableInitializer() :
{}
{
  Expression()
  | ArrayInitializer()
}

void MoreVariableDeclarators() :
{}
{
  [ <COMMA> VariableDeclarator() MoreVariableDeclarators() ]
}

void MethodDeclaration() :
{}
{
  MethodHeader() MethodBody()
}

void MethodHeader() :
{}
{
  AttributesOpt() MethodModifierList() PartialOpt() ReturnType() MemberName() TypeParameterListOpt() <LPAREN> FormalParameterListOpt() <RPAREN> TypeParameterConstraintsClauseList()
}

void MethodModifierList() :
{}
{
  [ MethodModifier() MethodModifierList() ]
}

void MethodModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
  | <STATIC>
  | <VIRTUAL>
  | <SEALED>
  | <OVERRIDE>
  | <ABSTRACT>
  | <EXTERN>
  | MethodModifierUnsafe()
}

void MethodModifierUnsafe() :
{}
{
  <UNSAFE>
}

void ReturnType() :
{}
{
  Type()
  | <VOID>
}

void MemberName() :
{}
{
  Identifier()
  | InterfaceType() <DOT> Identifier()
}

void FormalParameterListOpt() :
{}
{
  [ FormalParameterList() ]
}

void FormalParameterList() :
{}
{
  FixedParameters()
  | FixedParameters() <COMMA> ParameterArray()
  | ParameterArray()
}

void FixedParameters() :
{}
{
  FixedParameter() MoreFixedParameters()
}

void FixedParameter() :
{}
{
  AttributesOpt() ParameterModifierOpt() Type() Identifier() DefaultArgumentOpt()
}

void ParameterModifierOpt() :
{}
{
  [ ParameterModifier() ]
}

void ParameterModifier() :
{}
{
  <REF>
  | <OUT>
  | <THIS>
}

void DefaultArgumentOpt() :
{}
{
  [ DefaultArgument() ]
}

void DefaultArgument() :
{}
{
  <EQUAL> Expression()
}

void MoreFixedParameters() :
{}
{
  [ <COMMA> FixedParameter() MoreFixedParameters() ]
}

void ParameterArray() :
{}
{
  AttributesOpt() <PARAMS> ArrayType() Identifier()
}

void MethodBody() :
{}
{
  Block()
  | <EQUAL_GREATER> Expression() <SEMICOLON>
  | <SEMICOLON>
}

void StatementListOpt() :
{}
{
  StatementList()
}

void StatementList() :
{}
{
  [ Statement() StatementList() ]
}

void PropertyDeclaration() :
{}
{
  AttributesOpt() PropertyModifierList() Type() MemberName() PropertyBody()
}

void PropertyModifierList() :
{}
{
  [ PropertyModifier() PropertyModifierList() ]
}

void PropertyModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <INTERNAL>
  | <PRIVATE>
  | <STATIC>
  | <VIRTUAL>
  | <SEALED>
  | <OVERRIDE>
  | <ABSTRACT>
  | <EXTERN>
}

void PropertyBody() :
{}
{
  <LBRACE> AccessorDeclarations() <RBRACE> PropertyInitializerOpt()
  | <EQUAL_GREATER> Expression() <SEMICOLON>
}

void AccessorDeclarations() :
{}
{
  GetAccessorDeclaration() SetAccessorDeclaration()
  | GetAccessorDeclaration()
  | SetAccessorDeclaration() GetAccessorDeclaration()
  | SetAccessorDeclaration()
}

void GetAccessorDeclaration() :
{}
{
  AttributesOpt() AccessorModifierOpt() <GET> AccessorBody()
}

void AccessorModifierOpt() :
{}
{
  [ AccessorModifier() ]
}

void AccessorModifier() :
{}
{
  <PROTECTED> <INTERNAL>
  | <INTERNAL> <PROTECTED>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
}

void AccessorBody() :
{}
{
  Block()
  | <SEMICOLON>
}

void SetAccessorDeclaration() :
{}
{
  AttributesOpt() AccessorModifierOpt() <SET> AccessorBody()
}

void PropertyInitializerOpt() :
{}
{
  [ PropertyInitializer() ]
}

void PropertyInitializer() :
{}
{
  <EQUAL> VariableInitializer()
}

void EventDeclaration() :
{}
{
  AttributesOpt() EventModifierList() <EVENT> Type() MemberName() <LBRACE> EventAccessorDeclarations() <RBRACE>
  | AttributesOpt() EventModifierList() <EVENT> Type() VariableDeclarators() <SEMICOLON>
}

void EventModifierList() :
{}
{
 [ EventModifier() EventModifierList() ]
}

void EventModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
  | <STATIC>
  | <VIRTUAL>
  | <SEALED>
  | <OVERRIDE>
  | <ABSTRACT>
  | <EXTERN>
  | EventModifierUnsafe()
}

void EventModifierUnsafe() :
{}
{
  <UNSAFE>
}

void EventAccessorDeclarations() :
{}
{
  AddAccessorDeclaration() RemoveAccessorDeclaration()
  | RemoveAccessorDeclaration() AddAccessorDeclaration()
}

void AddAccessorDeclaration() :
{}
{
  AttributesOpt() <ADD> Block()
}

void RemoveAccessorDeclaration() :
{}
{
  AttributesOpt() <REMOVE> Block()
}

void IndexerDeclaration() :
{}
{
  AttributesOpt() IndexerModifierList() IndexerDeclarator() IndexerBody()
}

void IndexerModifierList() :
{}
{
  [ IndexerModifier() IndexerModifierList() ]
}

void IndexerModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
  | <VIRTUAL>
  | <SEALED>
  | <OVERRIDE>
  | <ABSTRACT>
  | <EXTERN>
  | IndexerModifierUnsafe()
}

void IndexerModifierUnsafe() :
{}
{
  <UNSAFE>
}

void IndexerDeclarator() :
{}
{
  Type() <THIS> <LBRACKET> FormalParameterList() <RBRACKET>
  | Type() InterfaceType() <DOT> <THIS> <LBRACKET> FormalParameterList() <RBRACKET>
}

void IndexerBody() :
{}
{
  <LBRACE> AccessorDeclarations() <RBRACE>
  | <EQUAL_GREATER> Expression() <SEMICOLON>
}

void OperatorDeclaration() :
{}
{
  AttributesOpt() OperatorModifierList() OperatorDeclarator() OperatorBody()
}

void OperatorModifierList() :
{}
{
  OperatorModifier() OperatorModifierList()
  | OperatorModifier()
}

void OperatorModifier() :
{}
{
  <PUBLIC>
  | <STATIC>
  | <EXTERN>
  | OperatorModifierUnsafe()
}

void OperatorModifierUnsafe() :
{}
{
  <UNSAFE>
}

void OperatorDeclarator() :
{}
{
  BinaryOperatorDeclarator()
  | UnaryOperatorDeclarator()
  | ConversionOperatorDeclarator()
}

void UnaryOperatorDeclarator() :
{}
{
  Type() <OPERATOR> OverloadableUnaryOperator() <LPAREN> Type() Identifier() <RPAREN>
}

void OverloadableUnaryOperator() :
{}
{
  <PLUS>
  | <MINUS>
  | <EXCLAMATION>
  | <TILDE>
  | <DBL_PLUS>
  | <DBL_MINUS>
  | <TRUE>
  | <FALSE>
}

void BinaryOperatorDeclarator() :
{}
{
  Type() <OPERATOR> OverloadableBinaryOperator() <LPAREN> Type() Identifier() <COMMA> Type() Identifier() <RPAREN>
}

void OverloadableBinaryOperator() :
{}
{
  <PLUS>
  | <MINUS>
  | <ASTERISK>
  | <SLASH>
  | <PERCENT>
  | <AMPERSAND>
  | <VERTICAL>
  | <CARET>
  | <DBL_LESS>
  | <DBL_GREATER>
  | <DBL_EQUAL>
  | <EXCL_EQUAL>
  | <GREATER>
  | <LESS>
  | <GREATER_EQUAL>
  | <LESS_EQUAL>
}

void ConversionOperatorDeclarator() :
{}
{
  <IMPLICIT> <OPERATOR> Type() <LPAREN> Type() Identifier() <RPAREN>
  | <EXPLICIT> <OPERATOR> Type() <LPAREN> Type() Identifier() <RPAREN>
}

void OperatorBody() :
{}
{
  Block()
  | <EQUAL_GREATER> Expression() <SEMICOLON>
  | <SEMICOLON>
}

void ConstructorDeclaration() :
{}
{
  AttributesOpt() ConstructorModifierList() ConstructorDeclarator() ConstructorBody()
}

void ConstructorModifierList() :
{}
{
  [ ConstructorModifier() ConstructorModifierList() ]
}

void ConstructorModifier() :
{}
{
  <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
  | <EXTERN>
  | ConstructorModifierUnsafe()
}

void ConstructorModifierUnsafe() :
{}
{
  <UNSAFE>
}

void ConstructorDeclarator() :
{}
{
  Identifier() <LPAREN> FormalParameterListOpt() <RPAREN> ConstructorInitializerOpt()
}

void ConstructorInitializerOpt() :
{}
{
  [ ConstructorInitializer() ]
}

void ConstructorInitializer() :
{}
{
  <COLON> <BASE> <LPAREN> ArgumentListOpt() <RPAREN>
  | <COLON> <THIS> <LPAREN> ArgumentListOpt() <RPAREN>
}

void ArgumentListOpt() :
{}
{
  [ ArgumentList() ]
}

void ArgumentList() :
{}
{
  Argument() MoreArguments()
}

void Argument() :
{}
{
  ArgumentNameOpt() ArgumentValue()
}

void MoreArguments() :
{}
{
  [ <COMMA> Argument() MoreArguments() ]
}

void ArgumentNameOpt() :
{}
{
  [ ArgumentName() ]
}

void ArgumentName() :
{}
{
  Identifier() <COLON>
}

void ArgumentValue() :
{}
{
  Expression()
  | <REF> VariableReference()
  | <OUT> VariableReference()
}

void VariableReference() :
{}
{
  Expression()
}

void ConstructorBody() :
{}
{
  Block()
  | <SEMICOLON>
}

void DestructorDeclaration() :
{}
{
  AttributesOpt() ExternOpt() <TILDE> Identifier() <LPAREN> <RPAREN> DestructorBody()
  | DestructorDeclarationUnsafe()
}

void ExternOpt() :
{}
{
  [ <EXTERN> ]
}

void DestructorBody() :
{}
{
  Block()
  | <SEMICOLON>
}

void DestructorDeclarationUnsafe() :
{}
{
  AttributesOpt() ExternOpt() UnsafeOpt() <TILDE> Identifier() <LPAREN> <RPAREN> DestructorBody()
  | AttributesOpt() UnsafeOpt() ExternOpt() <TILDE> Identifier() <LPAREN> <RPAREN> DestructorBody()
}

void UnsafeOpt() :
{}
{
  [ <UNSAFE> ]
}

void StaticConstructorDeclaration() :
{}
{
  AttributesOpt() StaticConstructorModifiers() Identifier() <LPAREN> <RPAREN> StaticConstructorBody()
}

void StaticConstructorModifiers() :
{}
{
  ExternOpt() <STATIC>
  | <STATIC> ExternOpt()
  | StaticConstructorModifiersUnsafe()
}

void StaticConstructorModifiersUnsafe() :
{}
{
  ExternOpt() UnsafeOpt() <STATIC>
  | UnsafeOpt() ExternOpt() <STATIC>
  | ExternOpt() <STATIC> UnsafeOpt()
  | UnsafeOpt() <STATIC> ExternOpt()
  | <STATIC> ExternOpt() UnsafeOpt()
  | <STATIC> UnsafeOpt() ExternOpt()
}

void StaticConstructorBody() :
{}
{
  Block()
  | <SEMICOLON>
}

void StructDeclaration() :
{}
{
  AttributesOpt() StructModifierList() PartialOpt() <STRUCT> Identifier() TypeParameterListOpt() StructInterfacesOpt() TypeParameterConstraintsClauseList() StructBody() SemicolonOpt()
}

void StructModifierList() :
{}
{
  [ StructModifier() StructModifierList() ]
}

void StructModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
  | StructModifierUnsafe()
}

void StructModifierUnsafe() :
{}
{
  <UNSAFE>
}

void StructInterfacesOpt() :
{}
{
  [ StructInterfaces() ]
}

void StructInterfaces() :
{}
{
  <COLON> InterfaceTypeList()
}

void StructBody() :
{}
{
  <LBRACE> StructMemberDeclarationList() <RBRACE>
}

void StructMemberDeclarationList() :
{}
{
  ConstantDeclaration()
  | FieldDeclaration()
  | MethodDeclaration()
  | PropertyDeclaration()
  | EventDeclaration()
  | IndexerDeclaration()
  | OperatorDeclaration()
  | ConstructorDeclaration()
  | StaticConstructorDeclaration()
  | TypeDeclaration()
  | StructMemberDeclarationUnsafe()
}

void StructMemberDeclarationUnsafe() :
{}
{
  FixedSizedBufferDeclaration()
}

void FixedSizedBufferDeclaration() :
{}
{
  AttributesOpt() FixedSizeBufferModifierList() <FIXED> BufferElementType() FixedSizeBufferDeclaratorList() <SEMICOLON>
}

void FixedSizeBufferModifierList() :
{}
{
  [ FixedSizeBufferModifier() FixedSizeBufferModifierList() ]
}

void FixedSizeBufferModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
  | <UNSAFE>
}

void BufferElementType() :
{}
{
  Type()
}

void FixedSizeBufferDeclaratorList() :
{}
{
  FixedSizeBufferDeclarator() FixedSizeBufferDeclaratorList()
  | FixedSizeBufferDeclarator()
}

void FixedSizeBufferDeclarator() :
{}
{
  Identifier() <LBRACKET> ConstantExpression() <RBRACKET>
}

void InterfaceDeclaration() :
{}
{
  AttributesOpt() InterfaceModifierList() PartialOpt() <INTERFACE> Identifier() VariantTypeParameterListOpt() InterfaceBaseOpt() TypeParameterConstraintsClauseList() InterfaceBody() SemicolonOpt()
}

void InterfaceModifierList() :
{}
{
  [ InterfaceModifier() InterfaceModifierList() ]
}

void InterfaceModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
  | InterfaceModifierUnsafe()
}

void InterfaceModifierUnsafe() :
{}
{
  <UNSAFE>
}

void VariantTypeParameterListOpt() :
{}
{
  [ VariantTypeParameterList() ]
}

void VariantTypeParameterList() :
{}
{
  <LESS> VariantTypeParameters() <GREATER>
}

void VariantTypeParameters() :
{}
{
  AttributesOpt() VarianceAnnotationOpt() TypeParameter() VariantTypeParametersPrime()
}

void VariantTypeParametersPrime() :
{}
{
  [ <COMMA> AttributesOpt() VarianceAnnotationOpt() TypeParameter() VariantTypeParametersPrime() ]
}

void VarianceAnnotationOpt() :
{}
{
  [ VarianceAnnotation() ]
}

void VarianceAnnotation() :
{}
{
  <IN>
  | <OUT>
}

void InterfaceBaseOpt() :
{}
{
  [ InterfaceBase() ]
}

void InterfaceBase() :
{}
{
  <COLON> InterfaceTypeList()
}

void InterfaceBody() :
{}
{
  <LBRACE> InterfaceMemberDeclarationList() <RBRACE>
}

void InterfaceMemberDeclarationList() :
{}
{
  [ InterfaceMemberDeclaration() InterfaceMemberDeclarationList() ]
}

void InterfaceMemberDeclaration() :
{}
{
  InterfaceMethodDeclaration()
  | InterfacePropertyDeclaration()
  | InterfaceEventDeclaration()
  | InterfaceIndexerDeclaration()
}

void InterfaceMethodDeclaration() :
{}
{
  AttributesOpt() NewOpt() ReturnType() Identifier() TypeParameterList() <LPAREN> FormalParameterListOpt() <RPAREN> TypeParameterConstraintsClauseList() <SEMICOLON>
}

void NewOpt() :
{}
{
  [ <NEW> ]
}

void InterfacePropertyDeclaration() :
{}
{
  AttributesOpt() NewOpt() Type() Identifier() <LBRACE> InterfaceAccessors() <RBRACE>
}

void InterfaceAccessors() :
{}
{
  AttributesOpt() <GET> <SEMICOLON> AttributesOpt() <SET> <SEMICOLON>
  | AttributesOpt() <SET> <SEMICOLON> AttributesOpt() <GET> <SEMICOLON>
  | AttributesOpt() <GET> <SEMICOLON>
  | AttributesOpt() <SET> <SEMICOLON>
}

void InterfaceEventDeclaration() :
{}
{
  AttributesOpt() NewOpt() <EVENT> Type() Identifier() <SEMICOLON>
}

void InterfaceIndexerDeclaration() :
{}
{
  AttributesOpt() NewOpt() Type() <THIS> <LBRACKET> FormalParameterList() <RBRACKET> <LBRACE> InterfaceAccessors() <RBRACE>
}

void EnumDeclaration() :
{}
{
  AttributesOpt() EnumModifierList() <ENUM> Identifier() EnumBaseOpt() EnumBody() SemicolonOpt()
}

void EnumModifierList() :
{}
{
  [ EnumModifier() EnumModifierList() ]
}

void EnumModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
}

void EnumBaseOpt() :
{}
{
  [ EnumBase() ]
}

void EnumBase() :
{}
{
  <COLON> IntegralType()
}

void EnumBody() :
{}
{
  <LBRACE> <RBRACE>
  | <LBRACE> EnumMemberDeclarations() <COMMA> <RBRACE>
  | <LBRACE> EnumMemberDeclarations() <RBRACE>
}

void EnumMemberDeclarations() :
{}
{
  EnumMemberDeclaration() MoreEnumMemberDeclarations()
}

void MoreEnumMemberDeclarations() :
{}
{
  [ <COMMA> EnumMemberDeclaration() MoreEnumMemberDeclarations() ]
}

void EnumMemberDeclaration() :
{}
{
  AttributesOpt() Identifier() <EQUAL> ConstantExpression()
  | AttributesOpt() Identifier()
}

void DelegateDeclaration() :
{}
{
  AttributesOpt() DelegateModifierList() <DELEGATE> ReturnType() Identifier() VariantTypeParameterListOpt() <LPAREN> FormalParameterListOpt() <RPAREN> TypeParameterConstraintsClauseList() SemicolonOpt()
}

void DelegateModifierList() :
{}
{
  [ DelegateModifier() DelegateModifierList() ]
}

void DelegateModifier() :
{}
{
  <NEW>
  | <PUBLIC>
  | <PROTECTED>
  | <INTERNAL>
  | <PRIVATE>
  | DelegateModifierUnsafe()
}

void DelegateModifierUnsafe() :
{}
{
  <UNSAFE>
}

void Expression() :
{}
{
  NonAssignmentExpression()
  | Assignment()
}

void NonAssignmentExpression() :
{}
{
  ConditionalExpression()
  | LambdaExpression()
  | QueryExpression()
}

void ConditionalExpression() :
{}
{
  NullCoalescingExpression()
  | NullCoalescingExpression() <QUESTION> Expression() <COLON> Expression()
}

void NullCoalescingExpression() :
{}
{
  ConditionalOrExpression()
  | ConditionalOrExpression() <DBL_QUESTION> NullCoalescingExpression()
}

void ConditionalOrExpression() :
{}
{
  ConditionalAndExpression() ConditionalOrExpressionPrime()
}

void ConditionalOrExpressionPrime() :
{}
{
  [ <DBL_VERTICAL> ConditionalAndExpression() ConditionalOrExpressionPrime() ]
}

void ConditionalAndExpression() :
{}
{
  InclusiveOrExpression() ConditionalAndExpressionPrime()
}

void ConditionalAndExpressionPrime() :
{}
{
  [ <DBL_AMPERSAND> InclusiveOrExpression() ConditionalAndExpressionPrime() ]
}

void InclusiveOrExpression() :
{}
{
  ExclusiveOrExpression() InclusiveOrExpressionPrime()
}

void InclusiveOrExpressionPrime() :
{}
{
  [ <VERTICAL> ExclusiveOrExpression() InclusiveOrExpressionPrime() ]
}

void ExclusiveOrExpression() :
{}
{
  AndExpression() ExclusiveOrExpressionPrime()
}

void ExclusiveOrExpressionPrime() :
{}
{
  [ <CARET> AndExpression() ExclusiveOrExpressionPrime() ]
}

void AndExpression() :
{}
{
  EqualityExpression() AndExpressionPrime()
}

void AndExpressionPrime() :
{}
{
  [ <AMPERSAND> EqualityExpression() AndExpressionPrime() ]
}

void EqualityExpression() :
{}
{
  RelationalExpression() EqualityExpressionPrime()
}

void EqualityExpressionPrime() :
{}
{
  <DBL_EQUAL> RelationalExpression() EqualityExpressionPrime()
  | <EXCL_EQUAL> RelationalExpression() EqualityExpressionPrime()
  | {}
}

void RelationalExpression() :
{}
{
  ShiftExpression() RelationalExpressionPrime()
}

void RelationalExpressionPrime() :
{}
{
  <LESS> ShiftExpression() RelationalExpressionPrime()
  | <GREATER> ShiftExpression() RelationalExpressionPrime()
  | <LESS_EQUAL> ShiftExpression() RelationalExpressionPrime()
  | <GREATER_EQUAL> ShiftExpression() RelationalExpressionPrime()
  | <IS> Type() RelationalExpressionPrime()
  | <AS> Type() RelationalExpressionPrime()
  | {}
}

void ShiftExpression() :
{}
{
  AdditiveExpression() ShiftExpressionPrime()
}

void ShiftExpressionPrime() :
{}
{
  <DBL_LESS> AdditiveExpression() ShiftExpressionPrime()
  | <DBL_GREATER> AdditiveExpression() ShiftExpressionPrime()
  | {}
}

void AdditiveExpression() :
{}
{
  MultiplicativeExpression() AdditiveExpressionPrime()
}

void AdditiveExpressionPrime() :
{}
{
  <PLUS> MultiplicativeExpression() AdditiveExpressionPrime()
  | <MINUS> MultiplicativeExpression() AdditiveExpressionPrime()
  | {}
}

void MultiplicativeExpression() :
{}
{
  UnaryExpression() MultiplicativeExpressionPrime()
}

void MultiplicativeExpressionPrime() :
{}
{
  <ASTERISK> UnaryExpression() MultiplicativeExpressionPrime()
  | <SLASH> UnaryExpression() MultiplicativeExpressionPrime()
  | <PERCENT> UnaryExpression() MultiplicativeExpressionPrime()
  | {}
}

void UnaryExpression() :
{}
{
  PrimaryExpression()
  | NullConditionalExpression()
  | <PLUS> UnaryExpression()
  | <MINUS> UnaryExpression()
  | <EXCLAMATION> UnaryExpression()
  | <TILDE> UnaryExpression()
  | PreIncrementExpression()
  | PreDecrementExpression()
  | CastExpression()
  | AwaitExpression()
  | UnaryExpressionUnsafe()
}

void PrimaryExpression() :
{}
{
  // PrimaryNoArrayCreationExpressionPrime() <LBRACKET> Expression() <RBRACKET> PrimaryExpressionPrime()
  PrimaryNoArrayCreationExpressionPrime() PrimaryExpressionPrime()
  | PrimaryNoArrayCreationExpressionPrime() <LBRACKET> ExpressionList() <RBRACKET> PrimaryExpressionPrime()
  | SizeofExpression() PrimaryExpressionPrime()
  | PredefinedType() <DOT> Identifier() TypeArgumentListOpt() PrimaryExpressionPrime()
  | QualifiedAliasMember() <DOT> Identifier() PrimaryExpressionPrime()
  | ArrayCreationExpression() PrimaryExpressionPrime()
}

void PrimaryExpressionPrime() :
{}
{
  <DOT> Identifier() TypeArgumentListOpt() PrimaryExpressionPrime()
  | <LPAREN> ArgumentListOpt() <RPAREN> PrimaryExpressionPrime()
  | <MINUS_GREATER> Identifier() PrimaryExpressionPrime()
   // | <DBL_PLUS> PrimaryExpressionPrime()
   // | <DBL_MINUS> PrimaryExpressionPrime()
  | {}
}

void PrimaryNoArrayCreationExpressionPrime() : // Without MemberAccess, ElementAccess, PostIncrementExpression, PostDecrementExpression, InvocationExpression and Unsafe
{}
{
  Literal()
  | ParanthesizedExpression()
  | ThisAccess()
  | BaseAccess()
  | ObjectCreationExpression()
  | DelegateCreationExpression()
  | AnonymousObjectCreationExpression()
  | TypeofExpression()
  | CheckedExpression()
  | UncheckedExpression()
  | DefaultValueExpression()
  | NameofExpression()
  | AnonymousMethodExpression()
  | SimpleName()
}

void PrimaryNoArrayCreationExpression() :
{}
{
  Literal() PrimaryNoArrayCreationExpressionPrime2()
  | SimpleName() PrimaryNoArrayCreationExpressionPrime2()
  | ParanthesizedExpression() PrimaryNoArrayCreationExpressionPrime2()
  | MemberAccess() PrimaryNoArrayCreationExpressionPrime2()
  | InvocationExpression() PrimaryNoArrayCreationExpressionPrime2()
  | ThisAccess() PrimaryNoArrayCreationExpressionPrime2()
  | BaseAccess() PrimaryNoArrayCreationExpressionPrime2()
  | PostIncrementExpression() PrimaryNoArrayCreationExpressionPrime2()
  | PostDecrementExpression() PrimaryNoArrayCreationExpressionPrime2()
  | ObjectCreationExpression() PrimaryNoArrayCreationExpressionPrime2()
  | DelegateCreationExpression() PrimaryNoArrayCreationExpressionPrime2()
  | AnonymousObjectCreationExpression() PrimaryNoArrayCreationExpressionPrime2()
  | TypeofExpression() PrimaryNoArrayCreationExpressionPrime2()
  | CheckedExpression() PrimaryNoArrayCreationExpressionPrime2()
  | UncheckedExpression() PrimaryNoArrayCreationExpressionPrime2()
  | DefaultValueExpression() PrimaryNoArrayCreationExpressionPrime2()
  | NameofExpression() PrimaryNoArrayCreationExpressionPrime2()
  | AnonymousMethodExpression() PrimaryNoArrayCreationExpressionPrime2()
  | PointerMemberAccess() PrimaryNoArrayCreationExpressionPrime2()
  | SizeofExpression() PrimaryNoArrayCreationExpressionPrime2()
}

void PrimaryNoArrayCreationExpressionPrime2() :
{}
{
  <LBRACKET> ExpressionList() <RBRACKET> PrimaryNoArrayCreationExpressionPrime2()
  // | <LBRACKET> Expression() <RBRACKET> PrimaryNoArrayCreationExpressionPrime2()
  | {}
}

void Literal() :
{ Token t; }
{
  t = <TRUE>                    { jjtThis.value = t.image; }
  | t = <FALSE>                 { jjtThis.value = t.image; }
  | t = <INTEGER_LITERAL>       { jjtThis.value = t.image; }
  | t = <REAL_LITERAL>          { jjtThis.value = t.image; }
  | t = <CHARACTER_LITERAL>     { jjtThis.value = t.image; }
  | t = <STRING_LITERAL>        { jjtThis.value = t.image; }
  | t = <NULL>                  { jjtThis.value = t.image; }
}

SimpleNode Identifier() :
{ Token t; }
{
  t = <IDENTIFIER>              { jjtThis.value = t.image; return jjtThis; }
}

void SimpleName() :
{}
{
  Identifier() TypeArgumentListOpt()
}

void ParanthesizedExpression() :
{}
{
  <LPAREN> Expression() <RPAREN>
}

void MemberAccess() :
{}
{
  PrimaryExpression() <DOT> Identifier() TypeArgumentListOpt()
  | PredefinedType() <DOT> Identifier() TypeArgumentListOpt()
  | QualifiedAliasMember() <DOT> Identifier()
}

void InvocationExpression() :
{}
{
  PrimaryExpression() <LPAREN> ArgumentListOpt() <RPAREN>
}

void ElementAccess() :
{}
{
  PrimaryNoArrayCreationExpression() <LBRACKET> ExpressionList() <RBRACKET>
}

void ExpressionList() :
{}
{
  Expression() MoreExpressions()
}

void MoreExpressions() :
{}
{
  [ <COMMA> Expression() MoreExpressions() ]
}

void ThisAccess() :
{}
{
  <THIS>
}

void BaseAccess() :
{}
{
  <BASE> <DOT> Identifier()
  | <BASE> <LBRACKET> ExpressionList() <RBRACKET>
}

void PostIncrementExpression() :
{}
{
  PrimaryExpression() <DBL_PLUS>
}

void PostDecrementExpression() :
{}
{
  PrimaryExpression() <DBL_MINUS>
}

void ObjectCreationExpression() :
{}
{
  <NEW> Type() <LPAREN> ArgumentListOpt() <RPAREN> ObjectOrCollectionInitializerOpt()
  | <NEW> Type() ObjectOrCollectionInitializerOpt()
}

void ObjectOrCollectionInitializerOpt() :
{}
{
  [ ObjectOrCollectionInitializer() ]
}

void ObjectOrCollectionInitializer() :
{}
{
  ObjectInitializer()
  | CollectionInitializer()
}

void ObjectInitializer() :
{}
{
  <LBRACE> MemberInitializerList() <COMMA> <RBRACE>
  | <LBRACE> MemberInitializerListOpt() <RBRACE>
}

void MemberInitializerListOpt() :
{}
{
  [ MemberInitializerList() ]
}

void MemberInitializerList() :
{}
{
  MemberInitializer() MoreMemberInitializers()
}

void MoreMemberInitializers() :
{}
{
  [ <COMMA> MemberInitializer() MoreMemberInitializers() ]
}

void MemberInitializer() :
{}
{
  InitializerTarget() <EQUAL> InitializerValue()
}

void InitializerTarget() :
{}
{
  Identifier()
  <LBRACKET> ArgumentList() <RBRACKET>
}

void InitializerValue() :
{}
{
  Expression()
  | ObjectOrCollectionInitializer()
}

void CollectionInitializer() :
{}
{
  <LBRACE> ElementInitializerList() <COMMA> <RBRACE>
  | <LBRACE> ElementInitializerList() <RBRACE>
}

void ElementInitializerList() :
{}
{
  ElementInitializer() MoreElementInitializers()
}

void MoreElementInitializers() :
{}
{
  [ <COMMA> ElementInitializer() MoreElementInitializers() ]
}

void ElementInitializer() :
{}
{
  NonAssignmentExpression()
  | <LBRACE> ExpressionList() <RBRACE>
}

void DelegateCreationExpression() :
{}
{
  <NEW> DelegateType() <LPAREN> Expression() <RPAREN>
}

void AnonymousObjectCreationExpression() :
{}
{
  <NEW> AnonymousObjectInitializer()
}

void AnonymousObjectInitializer() :
{}
{
  <LBRACE> MemberDeclarattorListOpt() <COMMA> <RBRACE>
  | <LBRACE> MemberDeclarattorListOpt() <RBRACE>
}

void MemberDeclarattorListOpt() :
{}
{
  [ MemberDeclaratorList() ]
}

void MemberDeclaratorList() :
{}
{
  MemberDeclarator() MoreMemberDeclarators()
}

void MoreMemberDeclarators() :
{}
{
  [ <COMMA> MemberDeclarator() MoreMemberDeclarators() ]
}

void MemberDeclarator() :
{}
{
  Identifier() <EQUAL> Expression()
  | SimpleName()
  | MemberAccess()
  | BaseAccess()
  | NullConditionalMemberAccess()
}

void NullConditionalMemberAccess() :
{}
{
  PrimaryExpression() NullConditionalOperationsOpt() <QUESTION> <DOT> Identifier() TypeArgumentListOpt()
  | PrimaryExpression() NullConditionalOperationsOpt() <DOT> Identifier() TypeArgumentListOpt()
}

void NullConditionalOperationsOpt() :
{}
{
  [ NullConditionalOperations() ]
}

void NullConditionalOperations() :
{}
{
  <QUESTION> <DOT> Identifier() TypeArgumentListOpt() NullConditionalOperationsPrime()
  | <QUESTION> <LBRACKET> ArgumentList() <RBRACKET> NullConditionalOperationsPrime()
}

void NullConditionalOperationsPrime() :
{}
{
  <QUESTION> <DOT> Identifier() TypeArgumentListOpt() NullConditionalOperationsPrime()
  | <QUESTION> <LBRACKET> ArgumentList() <RBRACKET> NullConditionalOperationsPrime()
  | <DOT> Identifier() TypeArgumentListOpt() NullConditionalOperationsPrime()
  | <LBRACKET> ArgumentList() <RBRACKET> NullConditionalOperationsPrime()
  | <LPAREN> ArgumentListOpt() <RPAREN> NullConditionalOperationsPrime()
  | {}
}

void TypeofExpression() :
{}
{
  <TYPEOF> <LPAREN> Type() <RPAREN>
  | <TYPEOF> <LPAREN> UnboundTypeName() <RPAREN>
  | <TYPEOF> <LPAREN> <VOID> <RPAREN>
}

void UnboundTypeName() :
{}
{
  Identifier() GenericDimensionSpecifierOpt() UnboundTypeNamePrime()
  | Identifier() <DBL_COLON> Identifier() GenericDimensionSpecifierOpt() UnboundTypeNamePrime()
}

void UnboundTypeNamePrime() :
{}
{
  [ <DOT> Identifier() GenericDimensionSpecifierOpt() UnboundTypeNamePrime() ]
}

void GenericDimensionSpecifierOpt() :
{}
{
  [ GenericDimensionSpecifier() ]
}

void GenericDimensionSpecifier() :
{}
{
  <LESS> CommaList() <GREATER>
}

void CommaList() :
{}
{
  [ <COMMA> CommaList() ]
}

void CheckedExpression() :
{}
{
  <CHECKED> <LPAREN> Expression() <RPAREN>
}

void UncheckedExpression() :
{}
{
  <UNCHECKED> <LPAREN> Expression() <RPAREN>
}

void DefaultValueExpression() :
{}
{
  <_DEFAULT> <LPAREN> Type() <RPAREN>
}

void NameofExpression() :
{}
{
  <NAMEOF> <LPAREN> NamedEntity() <RPAREN>
}

void NamedEntity() :
{}
{
  NamedEntityTargetPrime() <DOT> Identifier() TypeArgumentListOpt() NamedEntityPrime()
  | SimpleName() NamedEntityPrime()
}

void NamedEntityPrime() :
{}
{
  [ <DOT> Identifier() TypeArgumentListOpt() NamedEntityPrime() ]
}

void NamedEntityTargetPrime() : // Without NamedEntity
{}
{
  <THIS>
  | <BASE>
  | PredefinedType()
  | QualifiedAliasMember()
}

void NamedEntityTarget() :
{}
{
  <THIS>
  | <BASE>
  | NamedEntity()
  | PredefinedType()
  | QualifiedAliasMember()
}

void PredefinedType() :
{}
{
  <BOOL>
  | <BYTE>
  | <CHAR>
  | <DECIMAL>
  | <DOUBLE>
  | <FLOAT>
  | <INT>
  | <LONG>
  | <OBJECT>
  | <SBYTE>
  | <SHORT>
  | <STRING>
  | <UINT>
  | <ULONG>
  | <USHORT>
}

void AnonymousMethodExpression() :
{}
{
 <DELEGATE> ExplicitAnonymousFunctionSignatureOpt() Block()
}

void ExplicitAnonymousFunctionSignatureOpt() :
{}
{
  [ ExplicitAnonymousFunctionSignature() ]
}

void ExplicitAnonymousFunctionSignature() :
{}
{
  <LPAREN> ExplicitAnonymousFunctionParameterListOpt() <RPAREN>
}

void ExplicitAnonymousFunctionParameterListOpt() :
{}
{
  [ ExplicitAnonymousFunctionParameterList() ]
}

void ExplicitAnonymousFunctionParameterList() :
{}
{
  ExplicitAnonymousFunctionParameter() MoreExplicitAnonymousFunctionParameters()
}

void MoreExplicitAnonymousFunctionParameters() :
{}
{
  [ <COMMA> ExplicitAnonymousFunctionParameter() MoreExplicitAnonymousFunctionParameters() ]
}

void ExplicitAnonymousFunctionParameter() :
{}
{
  AnonymousFunctionParameterModifierOpt() Type() Identifier()
}

void AnonymousFunctionParameterModifierOpt() :
{}
{
  [ AnonymousFunctionParameterModifier() ]
}

void AnonymousFunctionParameterModifier() :
{}
{
  <REF>
  | <OUT>
}

void PrimaryNoArrayCreationExpressionUnsafe() :
{}
{
  PointerMemberAccess()
  | PointerElementAccess()
  | SizeofExpression()
}

void PointerMemberAccess() :
{}
{
  PrimaryExpression() <MINUS_GREATER> Identifier()
}

void PointerElementAccess() :
{}
{
  PrimaryNoArrayCreationExpression() <LBRACKET> Expression() <RBRACKET>
}

void SizeofExpression() :
{}
{
  <SIZEOF> <LPAREN> UnmanagedType() <RPAREN>
}

void ArrayCreationExpression() :
{}
{
  <NEW> ArrayType() ArrayInitializer()
  | <NEW> NonArrayType() <LBRACKET> ExpressionList() <RBRACKET> RankSpecifierListOpt() ArrayInitializerOpt()
  | <NEW> RankSpecifier() ArrayInitializer()
}

void RankSpecifierListOpt() :
{}
{
  [ RankSpecifierList() ]
}

void ArrayInitializerOpt() :
{}
{
  [ ArrayInitializer() ]
}

void ArrayInitializer() :
{}
{
  <LBRACE> VariableInitializerList() <COMMA> <RBRACE>
  | <LBRACE> VariableInitializerListOpt() <RBRACE>
}

void VariableInitializerListOpt() :
{}
{
  [ VariableInitializerList() ]
}

void VariableInitializerList() :
{}
{
  VariableInitializer() MoreVariableInitializers()
}

void MoreVariableInitializers() :
{}
{
  [ <COMMA> VariableInitializer() MoreVariableInitializers() ]
}

void NullConditionalExpression() :
{}
{
  PrimaryExpression() NullConditionalOperations()
}

void PreIncrementExpression() :
{}
{
  <DBL_PLUS> UnaryExpression()
}

void PreDecrementExpression() :
{}
{
  <DBL_MINUS> UnaryExpression()
}

void CastExpression() :
{}
{
  <LPAREN> Type() <RPAREN> UnaryExpression()
}

void AwaitExpression() :
{}
{
  <AWAIT> UnaryExpression()
}

void UnaryExpressionUnsafe() :
{}
{
  PointerIndirectionExpression()
  | AddressofExpression()
}

void PointerIndirectionExpression() :
{}
{
  <ASTERISK> UnaryExpression()
}

void AddressofExpression() :
{}
{
  <AMPERSAND> UnaryExpression()
}

void LambdaExpression() :
{}
{
  AnonymousFunctionSignature() <EQUAL_GREATER> AnonymousFunctionBody()
}

void AnonymousFunctionSignature() :
{}
{
  ExplicitAnonymousFunctionSignature()
  | ImplicitAnonymousFunctionSignature()
}

void ImplicitAnonymousFunctionSignature() :
{}
{
  <LPAREN> ImplicitAnonymousFunctionParameterListOpt() <RPAREN>
  | ImplicitAnonymousFunctionParameter()
}

void ImplicitAnonymousFunctionParameterListOpt() :
{}
{
  [ ImplicitAnonymousFunctionParameterList() ]
}

void ImplicitAnonymousFunctionParameterList() :
{}
{
  ImplicitAnonymousFunctionParameter() MoreImplicitAnonymousFunctionParameters()
}

void MoreImplicitAnonymousFunctionParameters() :
{}
{
  [ <COMMA> ImplicitAnonymousFunctionParameter() MoreImplicitAnonymousFunctionParameters() ]
}

void ImplicitAnonymousFunctionParameter() :
{}
{
  Identifier()
}

void AnonymousFunctionBody() :
{}
{
  Expression()
  | Block()
}

void QueryExpression() :
{}
{
  FromClause() QueryBody()
}

void FromClause() :
{}
{
  <FROM> TypeOpt() Identifier() <IN> Expression()
}

void TypeOpt() :
{}
{
  [ Type() ]
}

void QueryBody() :
{}
{
  QueryBodyClausesOpt() SelectOrGroupClause() QueryContinuationOpt()
}

void QueryBodyClausesOpt() :
{}
{
  [ QueryBodyClauses() ]
}

void QueryContinuationOpt() :
{}
{
  [ QueryContinuation() ]
}

void QueryBodyClauses() :
{}
{
  QueryBodyClause() QueryBodyClauses()
  | QueryBodyClause()
}

void QueryBodyClause() :
{}
{
  FromClause()
  | LetClause()
  | WhereClause()
  | JoinClause()
  | JoinIntoClause()
  | OrderbyClause()
}

void LetClause() :
{}
{
  <LET> Identifier() <EQUAL> Expression()
}

void WhereClause() :
{}
{
  <WHERE> BooleanExpression()
}

void BooleanExpression() :
{}
{
  Expression()
}

void JoinClause() :
{}
{
  <JOIN> TypeOpt() Identifier() <IN> Expression() <ON> Expression() <EQUALS> Expression()
}

void JoinIntoClause() :
{}
{
  <JOIN> TypeOpt() Identifier() <IN> Expression() <ON> Expression() <EQUALS> Expression() <INTO> Identifier()
}

void OrderbyClause() :
{}
{
  <ORDERBY> Orderings()
}

void Orderings() :
{}
{
  Ordering() MoreOrderings()
}

void MoreOrderings() :
{}
{
  [ <COMMA> Ordering() MoreOrderings() ]
}

void Ordering() :
{}
{
  Expression() OrderingDirectionOpt()
}

void OrderingDirectionOpt() :
{}
{
  [ OrderingDirection() ]
}

void OrderingDirection() :
{}
{
  <ASCENDING>
  | <DESCENDING>
}

void SelectOrGroupClause() :
{}
{
  SelectClause()
  | GroupClause()
}

void SelectClause() :
{}
{
  <SELECT> Expression()
}

void GroupClause() :
{}
{
  <GROUP> Expression() <BY> Expression()
}

void QueryContinuation() :
{}
{
  <INTO> Identifier() QueryBody()
}

void Assignment() :
{}
{
  UnaryExpression() AssignmentOperator() Expression()
}

void AssignmentOperator() :
{}
{
  <EQUAL>
  | <PLUS_EQUAL>
  | <MINUS_EQUAL>
  | <ASTERISK_EQUAL>
  | <SLASH_EQUAL>
  | <PERCENT_EQUAL>
  | <AMPERSAND_EQUAL>
  | <VERTICAL_EQUAL>
  | <CARET_EQUAL>
  | <DBL_LESS_EQUAL>
  | <DBL_GREATER_EQUAL>
}

void Statement() :
{}
{
  EmbeddedStatement()
  | DeclarationStatement()
  | LabeledStatement()
}

void LabeledStatement() :
{}
{
  Identifier() <COLON> Statement()
}

void DeclarationStatement() :
{}
{
  LocalConstantDeclaration() <SEMICOLON>
  | LocalVariableDeclaration() <SEMICOLON>
}

void LocalVariableDeclaration() :
{}
{
  LocalVariableType() LocalVariableDeclarators()
}

void LocalVariableType() :
{}
{
  Type()
  | <VAR>
}

void LocalVariableDeclarators() :
{}
{
  LocalVariableDeclarator() LocalVariableDeclaratorsPrime()
}

void LocalVariableDeclaratorsPrime() :
{}
{
  [ <COMMA> LocalVariableDeclarator() LocalVariableDeclaratorsPrime() ]
}

void LocalVariableDeclarator() :
{}
{
  Identifier() <EQUAL> LocalVariableInitializer()
  | Identifier()
}

void LocalVariableInitializer() :
{}
{
  Expression()
  | ArrayInitializer()
  | LocalVariableInitializerUnsafe()
}

void LocalVariableInitializerUnsafe() :
{}
{
  StackallocInitializer()
}

void StackallocInitializer() :
{}
{
  <STACKALLOC> UnmanagedType() <LBRACKET> Expression() <RBRACKET>
}

void LocalConstantDeclaration() :
{}
{
  <CONST> Type() ConstantDeclarators()
}

void EmbeddedStatement() :
{}
{
  Block()
  | EmptyStatement()
  | ExpressionStatement()
  | SelectionStatement()
  | IterationStatement()
  | JumpStatement()
  | TryStatement()
  | CheckedStatement()
  | UncheckedStatement()
  | LockStatement()
  | UsingStatement()
  | YieldStatement()
  | EmbeddedStatementUnsafe()
}

void Block() :
{}
{
  <LBRACE> StatementListOpt() <RBRACE>
}

void EmptyStatement() :
{}
{
  <SEMICOLON>
}

void ExpressionStatement() :
{}
{
  StatementExpression() <SEMICOLON>
}

void StatementExpression() :
{}
{
  InvocationExpression()
  | NullConditionalInvocationExpression()
  | ObjectCreationExpression()
  | Assignment()
  | PostIncrementExpression()
  | PostDecrementExpression()
  | PreIncrementExpression()
  | PreDecrementExpression()
  | AwaitExpression()
}

void NullConditionalInvocationExpression() :
{}
{
  PrimaryExpression() NullConditionalOperations() <LPAREN> ArgumentListOpt() <RPAREN>
}

void SelectionStatement() :
{}
{
  IfStatement()
  | SwitchStatement()
}

void IfStatement() :
{}
{
  <IF> <LPAREN> BooleanExpression() <RPAREN> EmbeddedStatement() <ELSE> EmbeddedStatement()
  | <IF> <LPAREN> BooleanExpression() <RPAREN> EmbeddedStatement()
}

void SwitchStatement() :
{}
{
  <SWITCH> <LPAREN> Expression() <RPAREN> SwitchBlock()
}

void SwitchBlock() :
{}
{
  <LBRACE> SwitchSectionList() <RBRACE>
}

void SwitchSectionList() :
{}
{
  [ SwitchSection() SwitchSectionList() ]
}

void SwitchSection() :
{}
{
  SwitchLabelList() StatementList()
}

void SwitchLabelList() :
{}
{
  SwitchLabel()
  | SwitchLabel() SwitchLabelList()
}

void SwitchLabel() :
{}
{
  <CASE> ConstantExpression() <COLON>
  | <_DEFAULT> <COLON>
}

void IterationStatement() :
{}
{
  WhileStatement()
  | DoStatement()
  | ForStatement()
  | ForeachStatement()
}

void WhileStatement() :
{}
{
  <WHILE> <LPAREN> BooleanExpression() <RPAREN> EmbeddedStatement()
}

void DoStatement() :
{}
{
  <DO> EmbeddedStatement() <WHILE> <LPAREN> BooleanExpression() <RPAREN> <SEMICOLON>
}

void ForStatement() :
{}
{
  <FOR> <LPAREN> ForInitializerOpt() <SEMICOLON> ForConditionOpt() <SEMICOLON> ForIteratorOpt() <RPAREN> EmbeddedStatement()
}

void ForInitializerOpt() :
{}
{
  [ ForInitializer() ]
}

void ForConditionOpt() :
{}
{
  [ ForCondition() ]
}

void ForIteratorOpt() :
{}
{
  ForIterator()
  | {}
}

void ForInitializer() :
{}
{
  LocalVariableDeclaration()
  | StatementExpressionList()
}

void StatementExpressionList() :
{}
{
  StatementExpression() MoreStatementExpressions()
}

void MoreStatementExpressions() :
{}
{
  [ <COMMA> StatementExpression() MoreStatementExpressions() ]
}

void ForCondition() :
{}
{
  BooleanExpression()
}

void ForIterator() :
{}
{
  StatementExpressionList()
}

void ForeachStatement() :
{}
{
  <FOREACH> <LPAREN> LocalVariableType() Identifier() <IN> Expression() <RPAREN> EmbeddedStatement()
}

void JumpStatement() :
{}
{
  BreakStatement()
  | ContinueStatement()
  | GotoStatement()
  | ReturnStatement()
  | ThrowStatement()
}

void BreakStatement() :
{}
{
  <BREAK> <SEMICOLON>
}

void ContinueStatement() :
{}
{
  <CONTINUE> <SEMICOLON>
}

void GotoStatement() :
{}
{
  <GOTO> Identifier() <SEMICOLON>
  | <GOTO> <CASE> ConstantExpression() <SEMICOLON>
  | <GOTO> <_DEFAULT> <SEMICOLON>
}

void ReturnStatement() :
{}
{
  <RETURN> ExpressionOpt() <SEMICOLON>
}

void ExpressionOpt() :
{}
{
  [ Expression() ]
}

void ThrowStatement() :
{}
{
  <THROW> ExpressionOpt() <SEMICOLON>
}

void TryStatement() :
{}
{
  <TRY> Block() CatchClauseList() FinallyClause()
  | <TRY> Block() CatchClauseList()
  | <TRY> Block() FinallyClause()
}

void CatchClauseList() :
{}
{
  CatchClause() CatchClauseList()
  | CatchClause()
}

void CatchClause() :
{}
{
  <CATCH> ExceptionSpecifierOpt() ExceptionFilterOpt() Block()
}

void ExceptionSpecifierOpt() :
{}
{
  [ ExceptionSpecifier() ]
}

void ExceptionFilterOpt() :
{}
{
  [ ExceptionFilter() ]
}

void ExceptionSpecifier() :
{}
{
  <LPAREN> Type() IdentifierOpt() <RPAREN>
}

void IdentifierOpt() :
{}
{
  [ Identifier() ]
}

void ExceptionFilter() :
{}
{
  <WHEN> <LPAREN> Expression() <RPAREN>
}

void FinallyClause() :
{}
{
  <FINALLY> Block()
}

void CheckedStatement() :
{}
{
  <CHECKED> Block()
}

void UncheckedStatement() :
{}
{
  <UNCHECKED> Block()
}

void LockStatement() :
{}
{
  <LOCK> <LPAREN> Expression() <RPAREN> EmbeddedStatement()
}

void UsingStatement() :
{}
{
  <USING> <LPAREN> ResourceAcquisition() <RPAREN> EmbeddedStatement()
}

void ResourceAcquisition() :
{}
{
  LocalVariableDeclaration()
  | Expression()
}

void YieldStatement() :
{}
{
  <YIELD> <RETURN> Expression() <SEMICOLON>
  | <YIELD> <BREAK> <SEMICOLON>
}

void EmbeddedStatementUnsafe() :
{}
{
  UnsafeStatement()
  | FixedStatement()
}

void UnsafeStatement() :
{}
{
  <UNSAFE> Block()
}

void FixedStatement() :
{}
{
  <FIXED> <LPAREN> PointerType() FixedPointerDeclarators() <RPAREN> EmbeddedStatement()
}

void FixedPointerDeclarators() :
{}
{
  FixedPointerDeclarator() MoreFixedPointerDeclarators()
}

void MoreFixedPointerDeclarators() :
{}
{
  [ <COMMA> FixedPointerDeclarator() MoreFixedPointerDeclarators() ]
}

void FixedPointerDeclarator() :
{}
{
  Identifier() <EQUAL> FixedPointerInitializer()
}

void FixedPointerInitializer() :
{}
{
  <AMPERSAND> VariableReference()
  | Expression()
}
